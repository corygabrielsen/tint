#!/bin/sh
# =============================================================================
# tint - terminal background color picker
# https://github.com/corygabrielsen/tint
# =============================================================================
#
# Compatibility:
#   Interactive picker (no args) requires bash for read -n/-t support.
#   All other commands work with any POSIX shell (dash, ash, sh):
#     tint <color>    tint --list    tint --reset    tint --help
#
#   Note: We use 'local' throughout. While not in POSIX spec, it's supported by
#   dash, ash, busybox sh, and every /bin/sh in practical use. See:
#   https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html
#   (Austin Group defect #767 - 'local' is planned for next POSIX revision)
#
# Install:
#   curl -fsSL https://raw.githubusercontent.com/corygabrielsen/tint/master/install.sh | bash
#
# Usage:
#   tint                  Interactive picker with live preview
#   tint <name|hex>       Set directly (e.g., "dracula", "#282a36")
#   tint random           Pick a random color
#   tint --reset          Reset to terminal default
#   tint --list           List available colors
#   tint --completions    Output shell completions (bash/zsh/fish)
#   tint --help           Show help
#
# Library usage:
#   source /path/to/tint
#   tint_pick "$current"  # Interactive picker (0=selected, 1=cancelled)
#   tint_set "#282a36"    # Set background
#   tint_reset            # Reset to default
#   tint_query            # Query current background
#
# Configuration:
#   TINT_PALETTE_FILE     Custom palette file (one "name:#hex" per line)
#   TINT_PALETTE          Inline palette override (newline-separated)
#
# =============================================================================

TINT_VERSION="0.5.0"

# Escape character for POSIX compatibility
_TINT_ESC=$(printf '\033')

# =============================================================================
# Palette
# =============================================================================

_TINT_DEFAULT_PALETTE='
black:#000000
vscode:#1e1e1e
dracula:#282a36
nord:#2e3440
gruvbox:#282828
onedark:#282c34
monokai:#272822
catppuccin:#1e1e2e
tokyo:#1a1b26
solarized:#002b36
github:#0d1117
rose-pine:#191724
night-owl:#011627
ayu:#0a0e14
cobalt:#193549
darcula:#2b2b2b
everforest:#2d353b
forest:#1a2e1a
horizon:#1c1e26
kanagawa:#1f1f28
material:#263238
midnight:#1a1a2e
navy:#1b2838
obsidian:#0e0e10
oxblood:#2e1a1a
palenight:#292d3e
slate:#1e2030
synthwave:#262335
ubuntu:#300a24
'

# See header comment re: 'local' keyword compatibility with POSIX shells.
_tint_load_palette() {
    # Priority: TINT_PALETTE env > TINT_PALETTE_FILE > default
    local palette_source="${_TINT_PALETTE_ENV:-}"
    # Check exists (-f), readable (-r), and guard with :- for set -u safety
    # Use || true so cat failure doesn't abort under set -e
    if [ -z "$palette_source" ] && [ -n "${TINT_PALETTE_FILE:-}" ] && [ -f "${TINT_PALETTE_FILE:-}" ] && [ -r "${TINT_PALETTE_FILE:-}" ]; then
        palette_source=$(cat "$TINT_PALETTE_FILE") || palette_source=""
    fi
    if [ -z "$palette_source" ]; then
        palette_source="$_TINT_DEFAULT_PALETTE"
    fi

    # Filter valid palette lines using sed and grep pipeline
    # 1. Strip inline comments and whitespace
    # 2. Remove empty lines and comment-only lines
    # 3. Keep only valid name:#hexcode format
    # Note: || true prevents exit under set -e if grep finds no matches
    TINT_PALETTE=$(printf '%s\n' "$palette_source" | \
        sed 's/ #.*//; s/^[[:space:]]*//; s/[[:space:]]*$//' | \
        grep -v '^$' | \
        grep -v '^#' | \
        grep -E '^[a-zA-Z0-9][a-zA-Z0-9_-]*:#[0-9a-fA-F]{6}$' || true)
}

# Initialize palette
# Track user's TINT_PALETTE separately from our loaded value to handle
# re-sourcing correctly: only update the saved user value when TINT_PALETTE
# has actually changed (user override), not when it matches our last load.
# Special case: if TINT_PALETTE is truly unset, the user explicitly removed
# the override — always update, since "unset" and "empty processed output"
# are otherwise indistinguishable via ${TINT_PALETTE:-}.
if [ -z "${TINT_PALETTE+set}" ] || [ "${TINT_PALETTE:-}" != "${_TINT_LOADED_PALETTE:-}" ]; then
    _TINT_USER_PALETTE="${TINT_PALETTE:-}"
fi
_TINT_PALETTE_ENV="${_TINT_USER_PALETTE:-}"
TINT_PALETTE=""
_tint_load_palette
_TINT_LOADED_PALETTE="$TINT_PALETTE"

# =============================================================================
# Palette Functions
# =============================================================================

# tint_lookup <name> - Look up color by name, print hex
tint_lookup() {
    local name="$1"
    local hex
    # Use awk for exact string matching - avoids regex metacharacter issues
    # (e.g., 'd.*' won't match 'dracula', '[' won't cause errors)
    hex=$(printf '%s\n' "$TINT_PALETTE" | awk -F: -v name="$name" '$1 == name {print $2; exit}')
    if [ -n "$hex" ]; then
        printf '%s' "$hex"
        return 0
    fi
    return 1
}

# tint_resolve <input> - Resolve name/hex/"none" to hex (empty for "none")
# Returns 0 on success, 1 on failure (safe under set -e)
tint_resolve() {
    local input="$1"
    [ "$input" = "none" ] && return 0
    printf '%s\n' "$input" | grep -qE '^#[0-9a-fA-F]{6}$' && { printf '%s' "$input"; return 0; }
    # Guard lookup failure to prevent set -e from aborting caller
    tint_lookup "$input" || return 1
}

# _tint_hex_to_rgb <hex> - Convert 6-digit hex to "r g b" (POSIX-safe)
_tint_hex_to_rgb() {
    local hex="${1#\#}"
    printf '%d %d %d' "0x${hex%????}" "0x$(echo "$hex" | cut -c3-4)" "0x${hex#????}"
}

# tint_list - Print all "name:#hex" entries with full-row background color
tint_list() {
    local entry name hex r g b fg
    printf '%s\n' "$TINT_PALETTE" | while IFS= read -r entry; do
        name="${entry%%:*}"
        hex="${entry#*:#}"
        # shellcheck disable=SC2046
        set -- $(_tint_hex_to_rgb "$hex")
        r=$1 g=$2 b=$3
        if [ $(( (r * 299 + g * 587 + b * 114) / 1000 )) -gt 128 ]; then
            fg="30"  # black text for light backgrounds
        else
            fg="97"  # bright white text for dark backgrounds
        fi
        printf '\033[%s;48;2;%d;%d;%dm %-16s #%s \033[0m\n' "$fg" "$r" "$g" "$b" "$name" "$hex"
    done
}

# tint_list_names - Print color names only
tint_list_names() {
    printf '%s\n' "$TINT_PALETTE" | cut -d: -f1
}

# _tint_palette_get <n> - Get nth palette entry (1-indexed)
_tint_palette_get() {
    printf '%s\n' "$TINT_PALETTE" | sed -n "${1}p"
}

# _tint_palette_count - Get number of palette entries
_tint_palette_count() {
    # Count non-empty lines. grep -c exits non-zero when no matches,
    # so we capture output first to avoid || echo appending a second "0"
    local count
    count=$(printf '%s\n' "$TINT_PALETTE" | grep -c . 2>/dev/null) || count=0
    printf '%s' "$count"
}

# =============================================================================
# Terminal Functions
# =============================================================================

# tint_set <hex> - Set terminal background via OSC 11
#
# Why >/dev/tty 2>/dev/null?
#
# /dev/tty is a "magic" device that refers to the process's controlling terminal.
# It's not a real file - it's a kernel abstraction. The device node exists in the
# filesystem (so [ -e /dev/tty ] and [ -w /dev/tty ] return true), but writing to
# it fails with ENXIO ("No such device or address") when no terminal is attached.
#
# This happens in: cron jobs, systemd services, `dash -c '...'`, detached processes.
# We suppress stderr rather than pre-checking because:
#   1. [ -w /dev/tty ] tests permission bits, not device connectivity
#   2. [ -t 0 ] can be true while /dev/tty still fails (edge cases)
#   3. Silently failing is correct behavior - no terminal means nothing to tint
#
# Implementation notes:
#   - Subshell ( ... ) ensures the redirection error itself is captured
#   - 2>/dev/null on the subshell catches "No such device or address"
#   - || true prevents set -e from treating tty absence as fatal
#   - This pattern works across bash, dash, and other POSIX shells
#
tint_set() {
    ( printf '\033]11;%s\033\\' "$1" >/dev/tty ) 2>/dev/null || true
}

# tint_reset - Reset to terminal profile default via OSC 111
# See tint_set for /dev/tty handling explanation.
tint_reset() {
    ( printf '\033]111\033\\' >/dev/tty ) 2>/dev/null || true
}

# tint_query - Query current background, return #rrggbb or fail
tint_query() {
    local hex
    hex=$(_tint_query_raw) || return 1
    if [ -n "$hex" ]; then
        printf '%s' "$hex"
        return 0
    fi
    return 1
}

# Internal: run terminal query in isolated subshell.
# Uses ( ) instead of { } so trap/stty changes can't leak to caller.
# All terminal I/O goes through /dev/tty explicitly, so the subshell
# capture ($(...)) doesn't interfere with stdin/stdout.
#
# Timeout: stty `time 2` = 200ms. This is a deliberate tradeoff: long enough
# for all known local and remote terminals to respond (the response is a single
# write from the terminal emulator), but short enough that non-responding
# terminals (e.g. TERM=dumb, serial consoles) don't block for seconds.
_tint_query_raw() (
    old_settings=$(stty -g 2>/dev/null </dev/tty) || exit 1
    stty raw -echo min 0 time 2 </dev/tty 2>/dev/null || {
        stty "$old_settings" </dev/tty 2>/dev/null
        exit 1
    }
    trap 'stty "$old_settings" </dev/tty 2>/dev/null' EXIT

    printf '\033]11;?\033\\' >/dev/tty
    response=$(dd bs=64 count=1 2>/dev/null </dev/tty | tr -d '\000')

    # Explicit restore (trap also fires on exit as safety net)
    stty "$old_settings" </dev/tty 2>/dev/null

    # Extract RGB: rgb:RRRR/GGGG/BBBB -> #RRGGBB (first 2 hex digits each)
    #
    # XParseColor allows 1-4 hex digits per component (h|hh|hhh|hhhh), but all known
    # terminals respond with 4 digits: xterm, VTE, urxvt, kitty, alacritty, foot (since
    # 2022). The regex requires 2+ digits, which safely handles all real-world responses.
    # See: https://codeberg.org/dnkl/foot/issues/971 (foot aligned to 4-digit standard)
    printf '%s' "$response" | sed -n 's/.*rgb:\([0-9a-fA-F]\{2\}\)[0-9a-fA-F]*\/\([0-9a-fA-F]\{2\}\)[0-9a-fA-F]*\/\([0-9a-fA-F]\{2\}\)[0-9a-fA-F]*.*/#\1\2\3/p'
)

# tint_supports_color - Check if we can reasonably expect terminal color support
#
# This is a heuristic, not a guarantee. We check:
#   1. TERM is not "dumb" (indicates minimal/no capabilities)
#   2. /dev/tty is writable (we have a controlling terminal)
#
# Note: [ -t 1 ] (stdout is a tty) is insufficient - we write to /dev/tty,
# not stdout. A process can have stdout redirected but still have a
# controlling terminal, or vice versa.
#
# We don't detect terminal multiplexers (tmux/screen) here. OSC 11 may or
# may not work through them depending on configuration. Users in tmux who
# want to change the *outer* terminal color need passthrough sequences,
# which we don't currently support.
#
tint_supports_color() {
    [ "${TERM:-dumb}" != "dumb" ] || return 1
    # Try opening /dev/tty for writing - this is the definitive check
    ( printf '' >/dev/tty ) 2>/dev/null || return 1
    return 0
}

# =============================================================================
# Interactive Picker
# =============================================================================

_tint_hide_cursor() { printf '\e[?25l' >/dev/tty; }
_tint_show_cursor() { printf '\e[?25h' >/dev/tty; }
_tint_term_lines() { tput lines 2>/dev/null || printf '%s' "${LINES:-24}"; }

_tint_erase_picker() {
    # Cursor is on the scroll indicator line (N rows below first palette row,
    # which is 1 line below the hint line).
    # Move up to the hint line: N (palette rows) + 1 (hint line)
    local n="${_TINT_RENDERED_ROWS:-0}"
    if [ "$n" -gt 0 ]; then
        printf '\e[%dA' "$(( n + 1 ))" >/dev/tty
    fi
    # Clear hint line + N palette rows + scroll indicator line
    local i=0
    while [ "$i" -le "$(( n + 1 ))" ]; do
        printf '\r\e[K\n' >/dev/tty
        i=$(( i + 1 ))
    done
    # Move back up to the hint line position
    printf '\e[%dA' "$(( n + 2 ))" >/dev/tty
}

_tint_cleanup() {
    _tint_show_cursor
    _tint_erase_picker
    # Restore terminal echo mode
    if [ -n "${_TINT_SAVED_STTY:-}" ]; then
        stty "$_TINT_SAVED_STTY" </dev/tty 2>/dev/null
    fi
    # Restore original background on signal interruption
    if [ -n "${_TINT_ORIGINAL_BG:-}" ]; then
        tint_set "$_TINT_ORIGINAL_BG"
    elif [ "${_TINT_PREVIEWED:-0}" -eq 1 ]; then
        tint_reset
    fi
}

# _tint_render_row <row_idx> <highlighted> <default_idx> <original_bg> <total>
# Prints a single picker row to stdout (caller redirects to /dev/tty).
# Uses _tint_names[] and _tint_hexes[] arrays (set by tint_pick).
_tint_render_row() {
    local row_idx="$1" highlighted="$2" default_idx="$3" original_bg="$4" total="$5"
    local name hex r g b tw fg marker label
    tw=${#total}

    if [ "$row_idx" -eq 0 ]; then
        if [ -n "$original_bg" ]; then name="(unchanged)"; else name="(reset to default)"; fi
        hex="$original_bg"
    else
        # shellcheck disable=SC3054
        name="${_tint_names[$row_idx]}"
        # shellcheck disable=SC3054
        hex="${_tint_hexes[$row_idx]}"
    fi

    # Build prefix: > for cursor, * for default, space otherwise
    if [ "$highlighted" -eq 1 ]; then
        marker="> "
    elif [ "$row_idx" -eq "$default_idx" ] || { [ "$row_idx" -eq 0 ] && [ "$default_idx" -gt 0 ]; }; then
        marker="* "
    else
        marker="  "
    fi

    if [ -n "$hex" ]; then
        r=$(printf '%d' "0x$(echo "$hex" | cut -c2-3)")
        g=$(printf '%d' "0x$(echo "$hex" | cut -c4-5)")
        b=$(printf '%d' "0x$(echo "$hex" | cut -c6-7)")
        # local is safe: _tint_render only runs inside tint_pick (bash guaranteed)
        local fg marker label
        if [ $(( (r * 299 + g * 587 + b * 114) / 1000 )) -gt 128 ]; then
            fg="30"
        else
            fg="97"
        fi
        label=$(printf '%*d.    #%s    %s' "$tw" "$((row_idx + 1))" "${hex#\#}" "$name")
        if [ "$highlighted" -eq 1 ]; then
            printf '%s\e[%s;48;2;%d;%d;%dm %-41s\e[0m' "$marker" "$fg" "$r" "$g" "$b" "$label"
        else
            printf '%s\e[2;%s;48;2;%d;%d;%dm %-41s\e[0m' "$marker" "$fg" "$r" "$g" "$b" "$label"
        fi
    else
        label=$(printf '%*d.    - - - -    %s' "$tw" "$((row_idx + 1))" "$name")
        if [ "$highlighted" -eq 1 ]; then
            printf '%s%-41s' "$marker" "$label"
        else
            printf '%s\e[2m%-41s\e[0m' "$marker" "$label"
        fi
    fi
}

# _tint_render_all <idx> <default_idx> <original_bg> <total> <visible>
# Draws the full visible window of picker rows.
_tint_render_all() {
    local idx="$1" default_idx="$2" original_bg="$3" total="$4" visible="$5"
    local i highlighted win_start win_end

    # Live preview: set terminal bg to highlighted color
    if [ "$idx" -eq 0 ]; then
        if [ -n "$original_bg" ]; then
            tint_set "$original_bg"
        elif [ "${_TINT_PREVIEWED:-0}" -eq 1 ]; then
            tint_reset
        fi
    else
        _TINT_PREVIEWED=1
        # shellcheck disable=SC3054
        tint_set "${_tint_hexes[$idx]}"
    fi

    # Compute scroll window (center cursor, clamp to edges)
    if [ "$visible" -ge "$total" ]; then
        win_start=0
        win_end=$(( total - 1 ))
    else
        local half=$(( visible / 2 ))
        win_start=$(( idx - half ))
        if [ "$win_start" -lt 0 ]; then win_start=0; fi
        win_end=$(( win_start + visible - 1 ))
        if [ "$win_end" -ge "$total" ]; then
            win_end=$(( total - 1 ))
            win_start=$(( win_end - visible + 1 ))
        fi
    fi

    # Move cursor up to first row position (for redraw).
    # Cursor is on the scroll indicator line (N rows below first row).
    if [ "${_TINT_RENDERED_ROWS:-0}" -gt 0 ]; then
        printf '\e[%dA' "$(( _TINT_RENDERED_ROWS ))" >/dev/tty
    fi

    # Draw each visible row
    local rows_printed=0
    i=$win_start
    while [ "$i" -le "$win_end" ]; do
        if [ "$i" -eq "$idx" ]; then highlighted=1; else highlighted=0; fi
        printf '\r\e[K' >/dev/tty
        _tint_render_row "$i" "$highlighted" "$default_idx" "$original_bg" "$total" >/dev/tty
        printf '\n' >/dev/tty
        rows_printed=$(( rows_printed + 1 ))
        i=$(( i + 1 ))
    done

    # Scroll indicator (only when entries are hidden)
    printf '\r\e[K' >/dev/tty
    if [ "$win_start" -gt 0 ] && [ "$win_end" -lt $(( total - 1 )) ]; then
        printf '\e[2m  \xe2\x86\x91 %d more \xc2\xb7 \xe2\x86\x93 %d more\e[0m' "$win_start" "$(( total - 1 - win_end ))" >/dev/tty
    elif [ "$win_start" -gt 0 ]; then
        printf '\e[2m  \xe2\x86\x91 %d more\e[0m' "$win_start" >/dev/tty
    elif [ "$win_end" -lt $(( total - 1 )) ]; then
        printf '\e[2m  \xe2\x86\x93 %d more\e[0m' "$(( total - 1 - win_end ))" >/dev/tty
    fi

    _TINT_RENDERED_ROWS=$rows_printed
}

# tint_pick [current] - Interactive picker
# Returns 0 with selected hex on stdout, or 1 with no output if cancelled.
tint_pick() {
    # Bash required for read -n/-t used in interactive picker.
    # Test actual bash array syntax in a subshell — simple presence checks
    # like ${BASH_VERSINFO:-} can be fooled by env var spoofing (e.g.,
    # BASH_VERSINFO=5 in dash). Only real bash can parse array subscripts.
    # The subshell catches the fatal "Bad substitution" without killing us.
    # shellcheck disable=SC3028,SC3054
    if ! (eval '[ "${BASH_VERSINFO[0]+_}" = _ ]') 2>/dev/null; then
        printf 'tint_pick: requires bash\n' >&2
        return 1
    fi
    # TTY required for interactive display. CLI entry (_tint_main) checks this
    # before calling tint_pick, but library callers may invoke it directly in
    # headless contexts (e.g., scripts, CI). Guard here to fail early with a
    # clear message rather than dying on the first >/dev/tty write.
    # Note: we check /dev/tty (not -t 0 / -t 1) because tint_pick uses /dev/tty
    # for all interactive I/O, while stdout carries the selected hex value.
    # Checking -t 1 would break hex=$(tint_pick) where stdout is a pipe.
    # Subshell probe: (: >/dev/tty) tests /dev/tty without mutating the
    # caller's fd table. Using exec 9>/dev/tty would close fd 9 in the
    # caller's shell, breaking code that already uses it.
    if ! (: >/dev/tty) 2>/dev/null; then
        printf 'tint_pick: requires a terminal (no TTY detected)\n' >&2
        return 1
    fi

    local current="${1:-}"
    local original_bg idx=0 default_idx=0 key key2 key3 entry i
    local palette_count
    palette_count=$(_tint_palette_count)
    local total=$(( palette_count + 1 ))
    local max=$(( total - 1 ))

    # Pre-load palette into arrays to avoid subshell forks on every render
    # shellcheck disable=SC3054
    local -a _tint_names _tint_hexes
    i=1
    while [ "$i" -le "$palette_count" ]; do
        entry=$(_tint_palette_get "$i")
        # shellcheck disable=SC3054
        _tint_names[i]="${entry%%:*}"
        # shellcheck disable=SC3054
        _tint_hexes[i]="${entry#*:}"
        i=$((i + 1))
    done

    # Calculate visible window size based on terminal height
    local term_lines visible
    term_lines=$(_tint_term_lines)
    visible=$(( term_lines - 2 ))  # reserve hint + scroll indicator
    if [ "$visible" -gt "$total" ]; then visible=$total; fi
    if [ "$visible" -lt 3 ]; then visible=3; fi
    _TINT_RENDERED_ROWS=0

    # Query current background. If this fails, the terminal doesn't support
    # OSC 11 and tint can't work — fail fast with a diagnostic message.
    if ! original_bg=$(tint_query); then
        cat >&2 <<'ERRMSG'
Error: terminal does not support OSC 11 (background color escape sequences).

tint uses OSC 11 to get and set the terminal background color.
Your terminal did not respond to the background color query,
which means tint cannot preview or apply colors.
ERRMSG
        if [ -n "${TMUX:-}" ]; then
            echo "  Hint: try running: tmux set -g allow-passthrough on" >&2
        elif [ -n "${SSH_TTY:-}${SSH_CONNECTION:-}" ]; then
            echo "  Hint: try reconnecting with: ssh -t" >&2
        fi
        printf '%s\n' "  Try: printf '\033]11;?\033\\\\'" >&2
        printf '  A supported terminal will echo back the current background color.\n' >&2
        return 1
    fi
    # Export for _tint_cleanup to restore on signal interruption
    _TINT_ORIGINAL_BG="$original_bg"
    # Track whether we've previewed any colors (for smart cancel behavior)
    _TINT_PREVIEWED=0

    # Find starting index if current setting matches a palette entry
    # Normalize current to lowercase hex for comparison (handles names and uppercase hex)
    if [ -n "$current" ]; then
        local current_hex
        current_hex=$(tint_resolve "$current" 2>/dev/null | tr '[:upper:]' '[:lower:]') || current_hex=""
        if [ -n "$current_hex" ]; then
            i=1
            while [ "$i" -le "$palette_count" ]; do
                entry=$(_tint_palette_get "$i")
                if [ "$(printf '%s' "${entry#*:}" | tr '[:upper:]' '[:lower:]')" = "$current_hex" ]; then
                    idx=$i
                    default_idx=$idx
                    break
                fi
                i=$((i + 1))
            done
        fi
    fi

    # Save existing traps to restore on exit (for library usage).
    # EXIT is saved separately and only restored when not in a subshell —
    # in command substitution (hex=$(tint_pick)), restoring EXIT would fire
    # the caller's trap prematurely, corrupting stdout output.
    # Uses BASH_SUBSHELL (Bash 3.0+) instead of BASHPID (Bash 4.0+) so
    # this works on Bash 3.2 (macOS default).
    local _tint_saved_traps _tint_saved_exit
    _tint_saved_traps=$(trap -p INT TERM 2>/dev/null || true)
    # shellcheck disable=SC3028
    if [ "${BASH_SUBSHELL:-0}" -eq 0 ]; then
        _tint_saved_exit=$(trap -p EXIT 2>/dev/null || true)
    else
        _tint_saved_exit=""
    fi

    # Use a flag for signal handling instead of exit, so we don't kill the
    # parent shell when sourced as a library. The read loop checks this flag.
    _TINT_INTERRUPTED=0
    # Suppress echo for entire picker session — read -rs only suppresses
    # during the read itself, allowing buffered input to echo during renders.
    _TINT_SAVED_STTY=$(stty -g </dev/tty 2>/dev/null)
    stty -echo </dev/tty 2>/dev/null
    trap '_tint_cleanup' EXIT
    trap '_tint_cleanup; _TINT_INTERRUPTED=130' INT
    trap '_tint_cleanup; _TINT_INTERRUPTED=143' TERM
    _tint_hide_cursor

    # Arrow keys send ESC + "[" + letter. 10ms timeout balances responsiveness
    # with giving slow connections time to send the full sequence. On very slow
    # links where arrow keys don't register, use vim keys (h/j/k/l) instead —
    # they are single characters and bypass the escape sequence timeout entirely.
    # Bash 4+ supports fractional timeouts; Bash 3.x needs integer (1 second min).
    local _tint_esc_timeout=0.01
    # shellcheck disable=SC3028
    local _tint_read_timeout=0.5
    # BASH_VERSINFO is checked with fallback
    # shellcheck disable=SC3028
    if [ "${BASH_VERSINFO[0]:-3}" -lt 4 ]; then
        _tint_esc_timeout=1
        _tint_read_timeout=1
    fi
    printf '\e[2m  \xe2\x86\x91/\xe2\x86\x93 Navigate   Enter: Select   Esc: Cancel\e[0m\n' >/dev/tty
    _tint_render_all "$idx" "$default_idx" "$original_bg" "$total" "$visible"

    while true; do
        # Check if interrupted by signal (Ctrl+C or SIGTERM)
        if [ "$_TINT_INTERRUPTED" -ne 0 ]; then
            trap - EXIT INT TERM; eval "$_tint_saved_traps"; eval "$_tint_saved_exit"
            return "$_TINT_INTERRUPTED"
        fi
        # Timeout ensures signal flag (_TINT_INTERRUPTED) gets checked even
        # when bash restarts read after a caught signal (SA_RESTART behavior).
        if ! IFS= read -rsn1 -t "$_tint_read_timeout" key </dev/tty; then
            # Check if interrupted by signal
            if [ "$_TINT_INTERRUPTED" -ne 0 ]; then
                trap - EXIT INT TERM; eval "$_tint_saved_traps"; eval "$_tint_saved_exit"
                return "$_TINT_INTERRUPTED"
            fi
            # Empty key = timeout, not EOF — loop and re-check
            if [ -z "${key:-}" ]; then continue; fi
            # EOF or read error - treat as cancel
            _tint_erase_picker
            if [ -n "$original_bg" ]; then
                tint_set "$original_bg"
            elif [ "$_TINT_PREVIEWED" -eq 1 ]; then
                tint_reset
            fi
            _tint_show_cursor; trap - EXIT INT TERM; eval "$_tint_saved_traps"; eval "$_tint_saved_exit"
            return 1
        fi
        # Re-check after read (signal may have fired during read)
        if [ "$_TINT_INTERRUPTED" -ne 0 ]; then
            trap - EXIT INT TERM; eval "$_tint_saved_traps"; eval "$_tint_saved_exit"
            return "$_TINT_INTERRUPTED"
        fi
        case "$key" in
            "$_TINT_ESC")
                if IFS= read -rsn1 -t "$_tint_esc_timeout" key2 </dev/tty 2>/dev/null; then
                    # CSI sequences: ESC [ A/B/C/D (most terminals)
                    # SS3 sequences: ESC O A/B/C/D (some terminals, notably older xterm modes)
                    case "$key2" in
                        "["|"O")
                            # Timeout on key3 prevents hang on malformed/partial escape sequences
                            IFS= read -rsn1 -t "$_tint_esc_timeout" key3 </dev/tty 2>/dev/null || continue
                            case "$key3" in
                                D|A) idx=$(( idx > 0 ? idx - 1 : max )) ;;
                                C|B) idx=$(( idx < max ? idx + 1 : 0 )) ;;
                            esac
                            _tint_render_all "$idx" "$default_idx" "$original_bg" "$total" "$visible"
                            ;;
                    esac
                else
                    # Escape pressed - cancel
                    _tint_erase_picker
                    if [ -n "$original_bg" ]; then
                        tint_set "$original_bg"
                    elif [ "$_TINT_PREVIEWED" -eq 1 ]; then
                        # Only reset if we previewed colors; otherwise leave untouched
                        tint_reset
                    fi
                    _tint_show_cursor; trap - EXIT INT TERM; eval "$_tint_saved_traps"; eval "$_tint_saved_exit"
                    return 1
                fi
                ;;
            h|k) idx=$(( idx > 0 ? idx - 1 : max )); _tint_render_all "$idx" "$default_idx" "$original_bg" "$total" "$visible" ;;
            l|j) idx=$(( idx < max ? idx + 1 : 0 )); _tint_render_all "$idx" "$default_idx" "$original_bg" "$total" "$visible" ;;
            q)
                _tint_erase_picker
                if [ -n "$original_bg" ]; then
                    tint_set "$original_bg"
                elif [ "$_TINT_PREVIEWED" -eq 1 ]; then
                    # Only reset if we previewed colors; otherwise leave untouched
                    tint_reset
                fi
                _tint_show_cursor; trap - EXIT INT TERM; eval "$_tint_saved_traps"; eval "$_tint_saved_exit"
                return 1
                ;;
            "")
                _tint_erase_picker
                _tint_show_cursor; trap - EXIT INT TERM; eval "$_tint_saved_traps"; eval "$_tint_saved_exit"
                # Return value semantics for tint_pick:
                #   - Return 0 = user confirmed selection (Enter key)
                #     Output: the selected hex color (or empty if original unknown)
                #   - Return 1 = user cancelled (Esc/q/EOF), no stdout output
                #   - Return 130/143 = interrupted by signal, no stdout output
                #
                # When idx=0 (unchanged) with empty original_bg and _TINT_PREVIEWED=1:
                #   We return 0 with empty output. This is intentional:
                #   - Return 0 means the user made a deliberate choice (to keep unchanged)
                #   - Empty output means we reset to terminal default (original unknown)
                #   - Callers should check BOTH return code AND output:
                #       hex=$(tint_pick "$current")
                #       if [ $? -eq 0 ]; then
                #           # User selected something
                #           [ -n "$hex" ] && save_color "$hex"  # Only save if we got a color
                #       fi
                if [ "$idx" -eq 0 ]; then
                    # Restore original background or reset to default
                    if [ -n "$original_bg" ]; then
                        tint_set "$original_bg"
                        printf '%s' "$original_bg"
                    else
                        # Label is "(reset to default)" - honor that choice
                        tint_reset
                    fi
                else
                    # shellcheck disable=SC3054
                    printf '%s' "${_tint_hexes[$idx]}"
                fi
                return 0
                ;;
        esac
    done
}

# =============================================================================
# Shell Completions
# =============================================================================

_tint_completions_bash() {
    cat <<'BASH_COMP'
_tint_completions() {
    local cur prev names opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    opts="--help --version --list --names --reset --query --completions show random"
    names=$(tint --names 2>/dev/null)

    case "$prev" in
        show)
            COMPREPLY=( $(compgen -W "$names" -- "$cur") )
            return ;;
        --completions)
            COMPREPLY=( $(compgen -W "bash zsh fish" -- "$cur") )
            return ;;
    esac

    if [[ "$cur" == -* ]]; then
        COMPREPLY=( $(compgen -W "$opts" -- "$cur") )
    else
        COMPREPLY=( $(compgen -W "$names random show" -- "$cur") )
    fi
}
complete -F _tint_completions tint
BASH_COMP
}

_tint_completions_zsh() {
    cat <<'ZSH_COMP'
#compdef tint

_tint() {
    local -a commands colors
    commands=(
        'show:Preview color swatch without setting'
        'random:Pick a random color'
        '--help:Show help'
        '--version:Show version'
        '--list:List available colors'
        '--names:List names only'
        '--reset:Reset to terminal default'
        '--query:Query current background'
        '--completions:Output shell completions'
    )
    colors=( ${(f)"$(tint --names 2>/dev/null)"} )

    if (( CURRENT == 2 )); then
        _describe 'command' commands
        _describe 'color' colors
    elif (( CURRENT == 3 )); then
        case "${words[2]}" in
            show)
                _describe 'color' colors ;;
            --completions)
                _values 'shell' bash zsh fish ;;
        esac
    fi
}

_tint "$@"
ZSH_COMP
}

_tint_completions_fish() {
    cat <<'FISH_COMP'
# Fish completions for tint
complete -c tint -x

# Options
complete -c tint -l help -d 'Show help'
complete -c tint -l version -d 'Show version'
complete -c tint -l list -d 'List available colors'
complete -c tint -l names -d 'List names only'
complete -c tint -l reset -d 'Reset to terminal default'
complete -c tint -l query -d 'Query current background'
complete -c tint -l completions -d 'Output shell completions' -xa 'bash zsh fish'

# Subcommands
complete -c tint -a 'show' -d 'Preview color swatch'
complete -c tint -a 'random' -d 'Pick a random color'

# Color names (dynamic)
complete -c tint -a '(tint --names 2>/dev/null)' -d 'Color name'
FISH_COMP
}

# =============================================================================
# CLI
# =============================================================================

_tint_usage() {
    cat <<'EOF'
tint - terminal background color picker

USAGE
    tint                  Interactive picker with live preview
    tint <name|hex>       Set background directly
    tint show <name|hex>  Preview color swatch without setting
    tint random           Pick a random color
    tint --reset          Reset to terminal default
    tint --query          Query current background
    tint --list           List available colors
    tint --names          List names only
    tint --completions    Output shell completions (bash/zsh/fish)
    tint --help           Show this help
    tint --version        Show version

INTERACTIVE CONTROLS
    ←/→  h/l              Navigate colors
    ↑/↓  k/j              Navigate colors
    Enter                 Select color
    Esc  q                Cancel (restore original)

EXAMPLES
    tint dracula          Set by name
    tint "#282a36"        Set by hex code
    tint show nord        Preview without setting
    tint random           Surprise me
    tint none             Reset and disable
    tint --list           Show all available colors

CONFIGURATION
    Custom palette file:  export TINT_PALETTE_FILE=~/.config/tint/palette.conf
    Inline palette:       export TINT_PALETTE=$'name1:#hex1\nname2:#hex2'

    Palette format (one per line):
        colorname:#hexcode

MORE INFO
    https://github.com/corygabrielsen/tint
EOF
}

_tint_main() {
    # Explicit empty argument is invalid, not interactive mode
    if [ $# -gt 0 ] && [ -z "$1" ]; then
        echo "error: color name cannot be empty" >&2
        exit 1
    fi
    # Reject extra arguments — most commands take at most one argument
    # Exceptions: "show" and "--completions" take a second argument
    if [ $# -gt 1 ] && [ "$1" != "show" ] && [ "$1" != "--completions" ]; then
        echo "error: unexpected argument: $2" >&2
        echo "Run 'tint --help' for usage" >&2
        exit 1
    fi
    case "${1:-}" in
        "")
            # Interactive mode requires bash for read -n/-t (single-char input).
            # We use /bin/sh shebang so non-interactive commands work on systems
            # without bash (Alpine, busybox). Re-exec into bash for interactive.
            # shellcheck disable=SC3028,SC3054
            if ! (eval '[ "${BASH_VERSINFO[0]+_}" = _ ]') 2>/dev/null; then
                # $0 contains the full path even when invoked via PATH - dash, zsh,
                # and busybox sh all resolve it. If bash is available, re-exec into
                # it. On systems without bash (e.g., Alpine), fall through to error.
                if command -v bash >/dev/null 2>&1; then
                    exec bash "$0" "$@"
                fi
                echo "error: interactive mode requires bash" >&2
                echo "usage: tint <color|hex>  or  tint --list" >&2
                exit 1
            fi
            if ! tint_supports_color; then
                echo "error: interactive mode requires a terminal" >&2
                echo "usage: tint <color|hex>  or  tint --list" >&2
                exit 1
            fi
            # local is safe: _tint_ensure_bash re-execs into bash before _tint_main
            local _tint_hex
            if _tint_hex=$(tint_pick); then
                if [ -n "$_tint_hex" ]; then printf '%s\n' "$_tint_hex"; fi
            fi
            ;;
        -h|--help)
            _tint_usage
            ;;
        -v|--version)
            echo "tint $TINT_VERSION"
            ;;
        -l|--list)
            tint_list
            ;;
        -n|--names)
            tint_list_names
            ;;
        -r|--reset)
            tint_reset
            echo "Reset to terminal default"
            ;;
        -q|--query)
            tint_query || { echo "Query failed" >&2; exit 1; }
            echo
            ;;
        --completions)
            case "${2:-bash}" in
                bash) _tint_completions_bash ;;
                zsh)  _tint_completions_zsh ;;
                fish) _tint_completions_fish ;;
                *)
                    echo "Unknown shell: $2" >&2
                    echo "Supported: bash, zsh, fish" >&2
                    exit 1
                    ;;
            esac
            ;;
        -*)
            echo "Unknown option: $1" >&2
            echo "Run 'tint --help' for usage" >&2
            exit 1
            ;;
        show)
            if [ -z "${2:-}" ]; then
                echo "error: missing color name or hex" >&2
                echo "usage: tint show <name|hex>" >&2
                exit 1
            fi
            # shellcheck disable=SC3043
            local show_hex show_r show_g show_b
            if show_hex=$(tint_resolve "$2"); then
                if [ -z "$show_hex" ]; then
                    echo "(default)" >&2
                    exit 0
                fi
                show_hex="${show_hex#\#}"
                # shellcheck disable=SC2046
                set -- $(_tint_hex_to_rgb "$show_hex")
                show_r=$1 show_g=$2 show_b=$3
                printf '\033[48;2;%d;%d;%dm    \033[0m  #%s\n' "$show_r" "$show_g" "$show_b" "$show_hex"
            else
                echo "Unknown color: $2" >&2
                echo "Run 'tint --list' for available colors" >&2
                exit 1
            fi
            ;;
        random)
            local count entry hex name idx
            count=$(_tint_palette_count)
            if [ "$count" -eq 0 ]; then
                echo "No colors in palette" >&2
                exit 1
            fi
            # Build seed in awk to avoid shell arithmetic octal pitfalls.
            # date +%N output can have leading zeros (octal in shell) or be
            # non-numeric on BSD/macOS. awk handles all of these safely.
            idx=$(awk -v max="$count" -v pid="$$" -v sec="$(date +%s)" \
                      -v nsec="$(date +%N 2>/dev/null || echo 0)" \
                      -v rnd="${RANDOM:-0}" \
                'BEGIN{ srand(pid * sec + rnd + (nsec+0)); print int(rand()*max)+1 }')
            entry=$(_tint_palette_get "$idx")
            name="${entry%%:*}"
            hex="${entry#*:}"
            tint_set "$hex"
            echo "$name $hex"
            ;;
        *)
            # local is de facto standard (see line 76)
            # shellcheck disable=SC3043
            local hex
            if hex=$(tint_resolve "$1"); then
                if [ -n "$hex" ]; then
                    tint_set "$hex"
                    echo "$hex"
                else
                    tint_reset
                    echo "Reset to terminal default"
                fi
            else
                echo "Unknown color: $1" >&2
                echo "Run 'tint --list' for available colors" >&2
                exit 1
            fi
            ;;
    esac
}

# Run CLI if executed directly (not sourced)
# When invoked as "bash tint" or "sh tint", $0 is the script path, not the shell.
# shellcheck disable=SC3028,SC3054
_tint_is_main() {
    # Bash: BASH_SOURCE[0] is array syntax that only works under bash.
    # Test array access in a subshell first — if BASH_VERSION leaks via
    # environment into dash/sh, the subshell catches the fatal "Bad
    # substitution" error without killing the parent script.
    if (eval '[ "${BASH_SOURCE[0]+_}" = _ ]') 2>/dev/null; then
        [ "${BASH_SOURCE[0]}" = "$0" ]
        return
    fi
    # Zsh: when executed, context is "toplevel" or "toplevel:shfunc"
    # When sourced, context contains ":file:"
    if [ -n "${ZSH_EVAL_CONTEXT:-}" ]; then
        case "$ZSH_EVAL_CONTEXT" in
            *:file:*|*:file) return 1 ;;  # Sourced
            toplevel*) return 0 ;;        # Executed
            *) return 1 ;;
        esac
    fi
    # POSIX fallback: check if $0 actually IS this script.
    # When executed (even via symlink/rename): $0 resolves to tint, which
    # contains our unique header URL. When sourced from another script: $0
    # is the calling script or shell, which won't have our marker.
    # Fast path: known shell names are definitely sourced.
    case "${0##*/}" in
        sh|dash|ash|bash|zsh|ksh|csh|tcsh|fish|-*) return 1 ;;
    esac
    # For other $0 values (symlinks, renames, or sourcing from scripts),
    # check if $0 contains our unique header URL (won't appear in caller scripts).
    # Note: a caller that includes this exact URL line would be a false positive,
    # but this is the best available POSIX heuristic (no reliable sourced-vs-exec
    # detection exists in POSIX sh). The anchored full URL makes collisions
    # negligible in practice.
    if [ -f "$0" ] && grep -qm1 '^# https://github.com/corygabrielsen/tint$' "$0" 2>/dev/null; then
        return 0  # Executed (tint, symlink, renamed copy)
    fi
    return 1  # Sourced from another script
}

if _tint_is_main; then
    set -eu
    _tint_main "$@"
fi
